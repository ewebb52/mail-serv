# Encrypted File Store (E-FS)
Maria Kogan (mk4036)

## Files
```
cstore/			                # cstore.c and dependencies, Makefile
crypto-algorithms/          # Open source implementation of cryptographic routines
cstore_test/		            # All test scripts and necessary environment set up (e.g. files added to E-FS)
README.md                   # This file, explaining the project
```
## Usage
```
cstore list archivename
cstore add [-p password] archivename file
cstore extract [-p password] archivename file
cstore delete [-p password] archivename file

```
## Dependencies
```
apt-get install valgrind
```

## To Test
```
cd cstore/
make
sudo make install
make test
```

## Attack Model
Attacker does not have root privileges of the system and thus is unable to trap between every operation and analyze the behavior of the system (see *Copy Cat : Controlled Instruction-Level Attacks on Enclaves*). Thus, attacker does not have access to page table accesses of the process and is unable to reconstruct the control flow at a high granularity. We assume that the operating system follows defined standards by POSIX (e.g. providing zero-d out pages to the process), and does not maliciously or accidentally provide incorrect return values and pointers to the system calls performed by the process (see *BesFS: A POSIX Filesystem for Enclaves with a Mechanized Safety Proof*). We assume that if this is run within a guest of a machine, the attacker does not have root access to the host machine and can snoop on the pages of the guest. The attacker is thus a guest on the same machine without root privileges, no ability to overload memory (see note in *Key Expansion and Protection* section), and can only access the archive by running cstore commands and having access to the final encrypted archive.

## AES Mode of Operation
E-FS utilizes Cipher Block Chaining (CBC) mode. This is considered the most popular mode of operation, 
as it combines the output of the previous encryption block with the plaintext of the next block. This means
that identical plaintexts are encrypted differently, which is critical for larger texts where recurrences
are increasingly probable (see Linux Penguin encryption gone wrong from lecture).

CBC requires an initialization vectore (IV) to behave as an extra block of ciphertext. It was generated by
hashing a random value retrieved from `/dev/urandom/` 10,000 times.

As CBC mode requires the input to be a multiple of the cipher's block size, the final block of plaintext
is padded with random values retrieved from `/dev/urandom/`, and the padding size is stored as metadata in the
E-FS. Padding with zeros was originally used, but later substituted due to the example in lecture where an all-zero IV yielded an encryption equivalent to plaintext. Due to the threat of massive parallel computers, AES-256 was used, ensuring protection of data for over 100 years.

## Integrity Protection
In CBC mode, it is necessary to include an integrity check as corruption is not propogated throughout a text's entirety. The integrity check is implemented utilizing a cryptographic hash function, SHA2-256. The Authentication was accomplished by implementing HMAC and performing it over the ciphertext and file metadata, ensuring that if any given files were combined (file1 = file1 + file2), the metadata would also be modified and the integrity check was failed. HMAC was implemented using this resource indicated on Piazza: https://tools.ietf.org/html/rfc2104

## Key Expansion and Protection
The key is generated utilizing the password provided when initiating a new E-FS. The key and password are not storred within the archive, as an incorrect password will fail the integrity check. The password is manually set to zero (and printed) upon being set to zero, to ensure that the security action is not optimized away by the compiler. Since we need separate keys for encryption and integrity checks, a "e" is appended to the password prior to hashing it to produce the encryption/decryption key, and an "i" is appended to the password prior to hashing it to generate the key utilized in integrity checks. MLock was considered, but not used, as the call to mlockall() consistently failed on the machine and prevented extensive testing. It is assumed that the attacker only has access to the E-FS within a given container with a memory limit and swap disabled (swapping can be disabled in the Kernel Configuration or by setting vm.swappiness to zero). Such actions would prevent the attacker from overloading the machine and swapping out any process data to disk, where the key would be persistent and accessible. Note: in each case, the key is generated from the modified password by iteratively applying SHA2-256 at least 10,000 times.

## Archive Format
All files stored within the archive are stored within the same file, appending each file metadata and encrypted plaintext. Deletion is performed via soft-delete only, as this practice keeps the history of the data, ensures quicker operations. Once an item has been soft deleted, it cannot be extracted using the cstore commands and must be re-added to be considered stored within E-FS.


## Interesting Tests
The tests are outlined in run-tests.sh (which is run by `make test`). The tests check for memory leaks and errors via `valgrind`. Each test is preceded by the action the test will take in brackets (e.g. [ File Not Provided on DELETE ]). Each test outputs PASS if there were no leaks or memory errors, and if the output is the expected output (this is checked via grep). For example, if we call `list` on the archive, and we expect it to out put 3 specific file names, we compare the output with a file that stores those expected file names in the same list and we compare the files). Tests also cat the exact output to confirm that no additional, unexpected output occurred. The actions associated with each test are printed prior to performing the test itself.

## Malicious Malloc Tests
I am  proud of this particular test. To perform this test, I overrode the defition of malloc such that
it randomly either calls the system definition of malloc or simply returns NULL (see `maliciousmalloc.h`). The function calls the system C library definition of malloc 90% of the time. After performing the traditiona tests, I recompile the E-FS with the flag -DMALICIOUS such that it links in this definition of malloc. Then, I iteratively run a series of testers to ensure that even when malloc failed (imitating an environment with high memory pressure), the E-FS reacts appropriately and aborts all operations without memory errors. This compilation is not installed, thus the cstore command would not randomly fail on malloc unless the environment is actually under memory pressure. This executable is later removed. Of course, the final version of E-FS would NOT have the option to link in the malicious malloc behavior, but it is included in this submission for testing purposes of edgecases that are difficult to produce.

## More on the tests...
Brief outline of each test and expected output is provided below:
* [ Initiating Archive by Adding First File ] Should add a file
* [ Adding Additional Files ] Should add more files
* [ Listing Files ] Should list the three files added
* [ Extracting File ] Should extract a file
* [ Deleting File ] Should delete a file
* [ Re-Listing Files ] Should list all files except deleted file from previos run
* [ Extracting Deleted File ] Should indicate that the file we are trying to extract does not exist in the archive because we deleted it from the archive in a previous run (validates behavior of soft delete)
* [ Re-Adding Deleted File ] Should successfully re - add a file that was soft deleted.
* [ Adding Duplicate File ] Should refuse to archive new file because it is a duplicate that is already stored in the archive 
* [ List/Extract/Delete Command Run On Invalid Archive ] Should abort without memory errors or leaks
* [ Extracting/Adding an Invalid File ] Should indicate that the file doesn't exist in the directory (to add) or in the archive (to extract)
* [ Extracting a File That Exists in Directory (should not overwrite) ] Should refuse to extract the file because a duplicate exists in the indicated directory, thus we can not initialize the new file to extract as we will not overwrite the file existing in the directory.
* [ Delete Run on an Invalid File ] File should not be found in archive
* [ File Not Provided when Adding/Extracting/Deleting ] should print the usage of the command as we have insufficient args.
* [ List a Malicious Archive ] Should abort without memory errors / leaks
* [ Integrity Check on Malicious Archive ] Should indicate that the integrity of archive has been compromised
* [ Malicious Password Inputted To Archive ] Should state that Integrity of archive has been compromised.
* [Malicious malloc ] Explained above.
